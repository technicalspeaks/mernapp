[
    {
    "Overview of Express": [
        "What is Express?",
        "ExpressJS is a web application framework that provides you with a simple API to build websites, web apps and back ends. With ExpressJS, you need not worry about low level protocols, processes, etc.Express provides a minimal interface to build our applications. It provides us the tools that are required to build our app. It is flexible as there are numerous modules available on npm, which can be directly plugged into Express.",
        ""
      ],
      "Express Installation": [
        "Install node",
        "I hope, node is installed in your device , if not please refer to the previous tutorials for nodejs and install node first . you can confirm node installation by the following steps\n\n1. open terminal.\n2. Run 'node --version' to verify node.\n3. Run npm --version to verfify npm",
        "Install Express",
        "Step 1 − Start your terminal/cmd, create a new folder named <your-project-name> and cd (create directory) into it \nStep 2 − Now to create the package.json file using npm, use the following code.\n\tnpm init\nIt will ask you for the following information.Just keep pressing enter, and enter your name at the “author name” field.\nStep 3 − Now we have our package.json file set up, we will further install Express. To install Express and add it to our package.json file, use the following command −\n\tnpm install --save express\nUse npm install -g express for global installation\n\nThis is all we need to start development using the Express framework. To make our development process a lot easier, we will install a tool from npm, nodemon. This tool restarts our server as soon as we make a change in any of our files, otherwise we need to restart the server manually after each file modification. To install nodemon, use the following command −\n\tnpm install -g nodemon "
      ],
      "Working in Express":[
        "How the App Works?",
        "Include following lines in js file:\n var express = require('express');\nvar app = express();\nIt imports Express in our file, we have access to it through the variable Express. We use it to create an application and assign it to var app.\nFollowing functions are used in express, you will implement one by one in this tutorials.\n1. app.get(route, callback):\n\tThis function tells what to do when a get request at the given route is called. The callback function has 2 parameters, request(req) and response(res). The request object(req) represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, etc. Similarly, the response object represents the HTTP response that the Express app sends when it receives an HTTP request.\n2. res.send()\n\tThis function takes an object as input and it sends this to the requesting client.\n3. app.listen(port, [host], [backlog], [callback]])\n\tThis function binds and listens for connections on the specified host and port. Port is the only required parameter here.\n\ta.\t\nport : A port number on which the server should accept incoming requests.\n\tb.\t\nhost : Name of the domain. You need to set it when you deploy your apps to the cloud.\n\tc.\t\nbacklog : The maximum number of queued pending connections. The default is 511.\n\td.\t\ncallback : An asynchronous function that is called when the server starts listening for requests"
      ],
      "First Program with Express": [
        "Hello World with Express",
        "// Import the top-level function of express\nconst express = require('express');\n// Creates an Express application using the top-level function\nconst app = express();\n// Define port number as 3000\nconst port = 3000;\n// Routes HTTP GET requests to the specified path \"/\" with the specified callback function\napp.get('/', function(request, response) {\n response.send('Hello, World!');\n});\n// Make the app listen on port 3000\napp.listen(port, function() {\n console.log('Server listening on http://localhost:' + port);\n});\n",
        "The following example uses Express to create an HTTP server listening on port 3000, which responds with \"Hello,\nWorld!\". Express is a commonly-used web framework that is useful for creating HTTP APIs.\nFirst, create a new folder, e.g. myApp. Go into myApp and make a new JavaScript file containing the following code\n(let's name it hello.js for example). Then install the express module using npm install --save express from the\ncommand line. Refer to this documentation for more information on how to install packages",
        "Output",
        "node hello.js",
        "From the command line, run the above command\nOpen your browser and navigate to http://localhost:3000 or http://127.0.0.1:3000 to see the response."
      ],
      "Routing in Express": [
        "Routing Example",
        "var express = require('express');\nvar app = express();\n\napp.get('/hello', function(req, res){\n   res.send(\"Hello World!\");\n});\n\napp.post('/hello', function(req, res){\n   res.send(\"You just called the post method at '/hello'!\\n\");\n});\n\napp.listen(3000);",
        "app.method(path, handler)\nThis METHOD can be applied to any one of the HTTP verbs – get, set, put, delete. An alternate method also exists, which executes independent of the request type.\n\nPath is the route at which the request will run.\n\nHandler is a callback function that executes when a matching request type is found on the relevant route.\nIn the above example,If we run our application and go to localhost:3000/hello, the server receives a get request at route \"/hello\", our Express app executes the callback function attached to this route and sends \"Hello World!\" as the response.",
        "Other methods",
        "// GET www.domain.com/myPath\napp.get('/myPath', function (req, res, next) {})\n// POST www.domain.com/myPath\napp.post('/myPath', function (req, res, next) {})\n// PUT www.domain.com/myPath\napp.put('/myPath', function (req, res, next) {})\n// DELETE www.domain.com/myPath\napp.delete('/myPath', function (req, res, next) {})\n/* If you want to define the same behavior for a route and all\nHTTP methods, you can use:*/\napp.all('/myPath', function (req, res, next) {})\n//or\napp.use('/myPath', function (req, res, next) {})\n//or\napp.use('*', function (req, res, next) {})\n// * wildcard will route for all paths",
        "There is a special routing method, app.all(), used to load middleware functions at a path for all HTTP request methods. For example, the following handler is executed for requests to the route “/secret” whether using GET, POST, PUT, DELETE, or any other HTTP request method supported in the http module.",
        "Chain route definitions for single path",
        "app.route('/myPath')\n .get(function (req, res, next) {})\n .post(function (req, res, next) {})\n .put(function (req, res, next) {})"
  
      ],
      "Route Paths (Dynamic Routing)": [
        "Dynamic Routing",
        "//This route path will match requests to the root route, /.\napp.get('/', function (req, res) {\n  res.send('root')\n})\n\n//This route path will match acd and abcd.\napp.get('/ab?cd', function (req, res) {\n  res.send('ab?cd')\n})\n\n//This route path will match abcd, abbcd, abbbcd, and so on.\napp.get('/ab+cd', function (req, res) {\n  res.send('ab+cd')\n})\n\n//This route path will match abcd, abxcd, abRANDOMcd, ab123cd, and so on.\napp.get('/ab*cd', function (req, res) {\n  res.send('ab*cd')\n})\n\n/*To define routes with route parameters, simply specify the route parameters in the path of the route as shown below.*/\napp.get('/users/:userId/books/:bookId', function (req, res) {\n  res.send(req.params)\n})\n\n /*Route path: /users/:userId/books/:bookId\nRequest URL: http://localhost:3000/users/34/books/8989\nreq.params: { \"userId\": \"34\", \"bookId\": \"8989\" }*/",
        "Route paths, in combination with a request method, define the endpoints at which requests can be made. Route paths can be strings, string patterns, or regular expressions.\n\nThe characters ?, +, *, and () are subsets of their regular expression counterparts. The hyphen (-) and the dot (.) are interpreted literally by string-based paths.\n\nIf you need to use the dollar character ($) in a path string, enclose it escaped within ([ and ]). For example, the path string for requests at “/data/$book”, would be “/data/([\\$])book”.",
        "Example",
        "router.get('/user/:id', function (req, res, next) {\n  // if the user ID is 0, skip to the next router\n  if (req.params.id === '0') console.log('id is equal to 0')\n  // otherwise pass control to the next middleware function in this stack\n  else console.log('id is not equal to 0')\n}, function (req, res, next) {\n  // render a regular page\n  res.render('done')\n})"
      ],
      "Middleware": [
        "Middleware funcions",
        "var express = require('express');\nvar app = express();\n\n//Middleware function to log request protocol\napp.use('/things', function(req, res, next){\n   console.log(\"A request for things received at \" + Date.now());\n   next();\n});\n\n// Route handler that sends the response\napp.get('/things', function(req, res){\n   res.send('Things');\n});\n\napp.listen(3000); ",
        "Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. These functions are used to modify req and res objects for tasks like parsing request bodies, adding response headers, etc.In the above example, We restrict it to a specific route (and all its subroutes), provide that route as the first argument of app.use().Now whenever you request any subroute of '/things', only then it will log the time.",
        "Third Party Middleware:body-parser",
        "var bodyParser = require('body-parser');\n\n//To parse URL encoded data\napp.use(bodyParser.urlencoded({ extended: false }))\n\n//To parse json data\napp.use(bodyParser.json())",
        "This is used to parse the body of requests which have payloads attached to them. To mount body parser, we need to install it using npm install --save body-parser and to mount it, include the following lines in your index.js",
        "Third Party Middleware:cookie-parser",
        "var cookieParser = require('cookie-parser');\napp.use(cookieParser())",
        "It parses Cookie header and populate req.cookies with an object keyed by cookie names. To mount cookie parser, we need to install it using npm install --save cookie-parser and to mount it, include the following lines in your index.js",
        "Third Party Middleware:express-session",
        "It creates a session middleware with the given options. We will discuss its usage in the Sessions section.\n\nWe have many other third party middleware in ExpressJS. However, we have discussed only a few important ones here."
      ],
      "Sessions in Express": [
        "Express-session",
        "npm install --save express-session",
        "HTTP is stateless; in order to associate a request to any other request, you need a way to store user data between HTTP requests. Cookies and URL parameters are both suitable ways to transport data between the client and the server. But they are both readable and on the client side. Sessions solve exactly this problem. You assign the client an ID and it makes all further requests using that ID. Information associated with the client is stored on the server linked to this ID.\n\nWe will need the Express-session, so install it using the code above.\nWe will put the session and cookie-parser middleware in place. In this example, we will use the default store for storing sessions, i.e., MemoryStore. Never use this in production environments. The session middleware handles all things for us, i.e., creating the session, setting the session cookie and creating the session object in req object.\n\nWhenever we make a request from the same client again, we will have their session information stored with us (given that the server was not restarted). We can add more properties to the session object",
        "Example",
        "var express = require('express');\nvar cookieParser = require('cookie-parser');\nvar session = require('express-session');\n\nvar app = express();\n\napp.use(cookieParser());\napp.use(session({secretKey: \"value\"}));\n\napp.get('/', function(req, res){\n   if(req.session.page_views){\n      req.session.page_views++;\n      res.send(\"You visited this page \" + req.session.page_views + \" times\");\n   } else {\n      req.session.page_views = 1;\n      res.send(\"Welcome to this page for the first time!\");\n   }\n});\napp.listen(3000);"
      ],
      "Image upload using multer": [
        "Multer Installation",
        "$ npm install --save multer",
        "Multer is a node.js middleware for handling multipart/form-data, which is primarily used for uploading files. It is written on top of busboy for maximum efficiency.\n\nNOTE: Multer will not process any form which is not multipart (multipart/form-data).",
        "Usage",
        "var express = require('express')\nvar multer  = require('multer')\nvar upload = multer({ dest: 'uploads/' })\n\nvar app = express()\n\napp.post('/profile', upload.single('avatar'), function (req, res, next) {\n  // req.file is the `avatar` file\n  // req.body will hold the text fields, if there were any\n})\n\napp.post('/photos/upload', upload.array('photos', 12), function (req, res, next) {\n  // req.files is array of `photos` files\n  // req.body will contain the text fields, if there were any\n})\n\nvar cpUpload = upload.fields([{ name: 'avatar', maxCount: 1 }, { name: 'gallery', maxCount: 8 }])\napp.post('/cool-profile', cpUpload, function (req, res, next) {\n  // req.files is an object (String -> Array) where fieldname is the key, and the value is array of files\n  //\n  // e.g.\n  //  req.files['avatar'][0] -> File\n  //  req.files['gallery'] -> Array\n  //\n  // req.body will contain the text fields, if there were any\n})",
        "Multer supports uploading single as well as multiple uploads.upload.singleis used for uploading a single file. As I have mentioned before multer adds a file object to the request. The file object contains metadata related with the file.\nYou will notice that the uploads folder is created in the location provided in dest option(in our case in the project directory) but you will notice the uploaded file do not contain any extension. If you want more controls over the uploads we will use the storage option instead of dest . Multer ships with storage engines DiskStorage and MemoryStorage .\nMulter adds a body object and a file or files object to the request object. The body object contains the values of the text fields of the form, the file or files object contains the files uploaded via the form.\n\nBasic usage example:\n\nDon’t forget the enctype=\"multipart/form-data\" in your form.In case you need to handle a text-only multipart form, you should use the .none() method",
        "Use Disk Storage",
        "var storage = multer.diskStorage({\n    destination: function(req, file, cb) {\n        cb(null, './upload');\n     },\n    filename: function (req, file, cb) {\n        cb(null , file.originalname);\n    }\n});\n//modify the upload variable to\nvar upload = multer({ storage: storage })\n",
        "The disk storage engine gives you full control of storing files to disk.we will create a storage object using storage (defined above)\nThere are two options available, destination and filename. They are both functions that determine where the file should be stored.\ndestination is used to determine within which folder the uploaded files should be stored. This can also be given as a string (e.g. '/tmp/uploads'). If no destination is given, the operating system's default directory for temporary files is used. An important thing to note here is we are responsible for creating the directory when providing destination as a function. When passing a string, multer will make sure that the directory is created for you.\nfilename is used to determine what the file should be named inside the folder. If no filename is given, each file will be given a random name that doesn't include any file extension. Also, Multer will not append any file extension for you, your function should return a filename complete with a file extension.\nEach function gets passed both the request (req) and some information about the file (file) to aid with the decision. I wanted to save the file with same name as they were uploaded so I am using file.originalname. You can have any name you want. On hitting the endpoint again You will notice the files uploaded in the upload folder have the same name and have an extension."],
      "Image upload using base64": [
        "Installing package",
        "npm install express body-parser multer --save",
        "Now we need to install such dependencies. Execute the above from your Command Prompt or Terminal",
        "Example",
        "var express = require(\"express\");\nvar bodyParser = require(\"body-parser\");\nvar multer = require(\"multer\");\nvar fs = require(\"fs\");\nvar app = express();\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.use(function(req, res, next) {\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\n    res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n    next();\n});\n\napp.post(\"/upload\", multer({dest: \"./uploads/\"}).array(\"uploads\", 12), function(req, res) {\n    var fileInfo = [];\n    for(var i = 0; i < req.files.length; i++) {\n        fileInfo.push({\n            \"originalName\": req.files[i].originalName,\n            \"size\": req.files[i].size,\n            \"b64\": new Buffer(fs.readFileSync(req.files[i].path)).toString(\"base64\")\n        });\n        fs.unlink(req.files[i].path);\n    }\n    res.send(fileInfo);\n});\n\nvar server = app.listen(3000, function() {\n    console.log(\"Listening on port %s...\", server.address().port);\n});",
        "var fs = require(\"fs\");\nWe’re including this dependency because we need to be able to read the file from the file system. The goal here is to accept the file upload, save it to the file system temporarily, read it to convert into base64, then do cleanup on the file system.\n\nThis snippet will replace the /upload endpoint in our app.js file. The first thing we do is loop through the array of files that were provided.\n\nWe’re going to push our own modified file data to a new array that will eventually be returned.\n\nThe file data that we want to keep is the original file name, file size, and then the base64 string representing the file itself. To get the base64 string we read the file synchronously from the file system, add it to a buffer and then convert it to a string. You certainly could use an asynchronous method for reading from the file system, but I chose the synchronous method for simplicity.\n\nAfter we push to our array we can delete the file from the file system. We don’t need to do this in a synchronous fashion so instead of holding up our execution we just unlink the files asynchronously."

      ],
      "Connecting Express to mysql": [
        "Installation",
        "$ npm install mysql",
        "",
        "Example",
        "var mysql = require('mysql')\nvar connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'dbuser',\n  password: 's3kreee7',\n  database: 'my_db'\n})\n\nconnection.connect()\n\nconnection.query('SELECT 1 + 1 AS solution', function (err, rows, fields) {\n  if (err) throw err\n\n  console.log('The solution is: ', rows[0].solution)\n})\n\nconnection.end()"
      ],
      "Connecting Express to Oracle": [
        "Installation",
        "$ npm install oracledb",
        "",
        "Example",
        "const oracledb = require('oracledb')\nconst config = {\n  user: '<your db user>',\n  password: '<your db password>',\n  connectString: 'localhost:1521/orcl'\n}\n\nasync function getEmployee (empId) {\n  let conn\n\n  try {\n    conn = await oracledb.getConnection(config)\n\n    const result = await conn.execute(\n      'select * from employees where employee_id = :id',\n      [empId]\n    )\n\n    console.log(result.rows[0])\n  } catch (err) {\n    console.log('Ouch!', err)\n  } finally {\n    if (conn) { // conn assignment worked, need to close\n      await conn.close()\n    }\n  }\n}\n\ngetEmployee(101)"
      ]
    }
]