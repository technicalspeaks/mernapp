[
    {
        "Introduction to React ": [
            "What is React?",
            "React is a JavaScript library created by Facebook.\nIts featues:\n1. React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes.\n2. Build encapsulated components that manage their own state, then compose them to make complex UIs.\n3. We don’t make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code.",
            "How does React Work?",
            "React creates a VIRTUAL DOM in memory.\n\nInstead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, before making the changes in the browser DOM.\n\nReact only changes what needs to be changed!\n\nReact finds out what changes have been made, and changes only what needs to be changed."
        ],
        "Setup guide": [
            "Node and npm",
            "Verify your versions of node and npm on the command line.If node and npm is not installed please reffer to NodeJs tutorial and check installation step for the same.",
            "Create the Root Folder",
            "Create a folder with name reactApp on the desktop to install all the required files.o create any module, it is required to generate the package.json file. Therefore, after Creating the folder, we need to create a package.json file. To do so you need to run the npm init command from the command prompt.This command asks information about the module such as packagename, description, author etc. you can skip these using the –y option.",
            "Install React and react dom",
            "Since our main task is to install ReactJS, install it, and its dom packages, using install react and react-dom commands of npm respectively. You can add the packages we install, to package.json file using the --save option.\n\nC:\\Users\\DevAtom\\Desktop\\reactApp>npm install react --save\nC:\\Users\\DevAtom\\Desktop\\reactApp>npm install react-dom --save\nOr, you can install all of them in single command as −\n\nC:\\Users\\DevAtom\\Desktop\\reactApp>npm install react react-dom --save",
            "create-react-app command",
            "Browse through the desktop and install the Create React App using command prompt as shown below −\n\nC:\\Users\\DevAtom>cd C:\\Users\\DevAtom\\Desktop\\\nC:\\Users\\DevAtom\\Desktop>npx create-react-app my-app\nThis will create a folder named my-app on the desktop and installs all the required files in it.",
            "Run the project",
            "Finally, run the project using the start command.\n\nnpm start"
        ],
        "Introduction to JSX": [
            "",
            "Now we will get to know JSX, the syntax in React. As mentioned before, create-react-app has already bootstrapped a basic application for you, and all files come with their own default implementations. For now, the only file we will modify is the src/App.js file.\n\nsrc/App.js\n\n\nimport React, { Component } from 'react';\n\nimport logo from './logo.svg';\n\nimport './App.css';\n\nclass App extends Component {\n\nrender() {\n\nreturn (\n\n<div className=\"App\">\n\n<header className=\"App-header\">\n\n<img src={logo} className=\"App-logo\" alt=\"logo\" /> <p>\n\nEdit <code>src/App.js</code> and save to reload.\n\n</p>\n\n<a\n\nclassName=\"App-link\"\n\nhref=\"https://reactjs.org\"\n\ntarget=\"_blank\"\n\nrel=\"noopener noreferrer\"\n\n>\n\nLearn React\n\n</a>\n\n</header>\n\n</div>\n\n);\n\n}\n\n}\n\nexport default App;\n\n\n\nDon’t worry if you’re confused by the import/export statements and class declaration now. These are features of JavaScript ES6 we will revisit in a later chapter.\n\nIn the file you should see a React ES6 class component with the name App. This is a component declaration. After you have declared a component, you can use it as an element anywhere in your application. It will produce an instance of your component or, in other words, the component gets instantiated.\nCode Playground\n\n\n//\tcomponent declaration class App extends Component {\n...\n\n}\n\n//\tcomponent usage (also called instantiation for a class)\n\n//\tcreates an instance of the component\n\n<App />\n\n\n\nThe returned element is specified in the render() method. The components you instantiated earlier are made up of elements, so it is important to understand the differences between a component, an instance of a component, and an element.\n\nYou should see where the App component is instantiated, else you couldn’t see the rendered output in a browser. The App component is only the declaration, but not the usage. You can instantiate the component anywhere in your JSX with <App />. You will see later where this happens in this application.\n\nThe content in the render block may look similar to HTML, but it is actually JSX. JSX allows you to mix HTML and JavaScript. It is powerful, but it can be confusing when you are used to separating the two languages. It is a good idea to start by using basic HTML in your JSX. Open the App.js file and remove all unnecessary HTML code as shown:\n\nsrc/App.js\n\n\nimport React, { Component } from 'react';\n\nimport './App.css';\n\nclass App extends Component {\n\nrender() {\n\nreturn (\n\n<div className=\"App\">\n\n<h2>Welcome to the Road to learn React</h2> </div>\n\n);\n\n}\n\n}\n\nexport default App;\n\n\n\nNow, you only return HTML in your render() method without any JavaScript. Let’s define the “Welcome to the Road to learn React” as a variable. A variable is set in JSX by curly braces.\n \nsrc/App.js\n\n\nimport React, { Component } from 'react';\n\nimport './App.css';\n\nclass App extends Component {\n\nrender() {\n\nvar helloWorld = 'Welcome to the Road to learn React';\n\nreturn (\n\n<div className=\"App\">\n\n<h2>{helloWorld}</h2>\n\n</div>\n\n);\n\n}\n\n}\n\nexport default App;\n\n\n\nStart your application on the command line with npm start to verify the changes you’ve made.\n\nYou might have noticed the className attribute. It reflects the standard class attribute in HTML. JSX had replaced a handful of internal HTML attributes, but you can find all the supported HTML attributes in React’s documentation⁵⁴, which all follow the camelCase convention. On your way to learn React, expect to run across more JSX specific attributes.\n",
            "ReactDOM",
            "The App component is located in your entry point to the React world: the src/index.js file.\n\nsrc/index.js\n\n\nimport React from 'react';\n\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\n\nimport './index.css';\n\nReactDOM.render(\n\n<App />,\n\ndocument.getElementById('root')\n\n);\n\n\n\nReactDOM.render() uses a DOM node in your HTML to replace it with JSX. It’s a way to integrate React in any foreign application easily, and you can use ReactDOM.render() multiple times across your application. You can use it to bootstrap simple JSX syntax, a React component, multiple React components, or an entire application. In a plain React application, you would only use it once to bootstrap the component tree.\n\nReactDOM.render() expects two arguments. The first argument is for rendering the JSX. The second argument specifies the place where the React application hooks into your HTML. It expects an element with an id='root', found in the public/index.html file.\n\nCode Playground\n\n\nReactDOM.render(\n\n<h1>Hello React World</h1>,\n\ndocument.getElementById('root')\n\n);\n\n\n\nDuring implementation, ReactDOM.render() takes your App component, though it can also pass simple JSX. It doesn’t require a component instance.\n"
        ],
        "Components": [
            "Stateless Example",
            "App.jsx\n\n\nimport React from 'react';\n\nclass App extends React.Component {\n   render() {\n      return (\n         <div>\n            <Header/>\n            <Content/>\n         </div>\n      );\n   }\n}\nclass Header extends React.Component {\n   render() {\n      return (\n         <div>\n            <h1>Header</h1>\n         </div>\n      );\n   }\n}\nclass Content extends React.Component {\n   render() {\n      return (\n         <div>\n            <h2>Content</h2>\n            <p>The content text!!!</p>\n         </div>\n      );\n   }\n}\nexport default App;",
            "Our first component in the following example is App. This component is owner of Header and Content. We are creating Header and Content separately and just adding it inside JSX tree in our App component. Only App component needs to be exported.To be able to render this on the page, we need to import it in main.js file and call reactDOM.render(). We already did this while setting the environment.",
            "Stateful Example",
            "App.jsx\n\n\nimport React from 'react';\n\nclass App extends React.Component {\n   constructor() {\n      super();\n      this.state = {\n         data: \n         [\n            {\n               \"id\":1,\n               \"name\":\"Foo\",\n               \"age\":\"20\"\n            },\n            {\n               \"id\":2,\n               \"name\":\"Bar\",\n               \"age\":\"30\"\n            },\n            {\n               \"id\":3,\n               \"name\":\"Baz\",\n               \"age\":\"40\"\n            }\n         ]\n      }\n   }\n   render() {\n      return (\n         <div>\n            <Header/>\n            <table>\n               <tbody>\n                  {this.state.data.map((person, i) => <TableRow key = {i} \n                     data = {person} />)}\n               </tbody>\n            </table>\n         </div>\n      );\n   }\n}\nclass Header extends React.Component {\n   render() {\n      return (\n         <div>\n            <h1>Header</h1>\n         </div>\n      );\n   }\n}\nclass TableRow extends React.Component {\n   render() {\n      return (\n         <tr>\n            <td>{this.props.data.id}</td>\n            <td>{this.props.data.name}</td>\n            <td>{this.props.data.age}</td>\n         </tr>\n      );\n   }\n}\nexport default App;",
            "In this example, we will set the state for owner component (App). The Header component is just added like in the last example since it doesn't need any state. Instead of content tag, we are creating table and tbody elements, where we will dynamically insert TableRow for every object from the data array.\n\nIt can be seen that we are using EcmaScript 2015 arrow syntax (=>) which looks much cleaner than the old JavaScript syntax. This will help us create our elements with fewer lines of code. It is especially useful when we need to create a list with a lot of items.\n\nNote − Notice that we are using key = {i} inside map() function. This will help React to update only the necessary elements instead of re-rendering the entire list when something changes. It is a huge performance boost for larger number of dynamically created elements.",
            "main.js file for both Stateless and Stateful Example",
            "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App.jsx';\n\nReactDOM.render(<App/>, document.getElementById('app'));"
        ],
        "Local Component State": [
            "State in a Component",
            "src/App.js\n\n\nclass App extends Component {\n\nconstructor(props) {\n\nsuper(props);\n\n}\n\n...\n\n}\n",
            "Local component state, also known as internal component state, allows you to save, modify, and delete properties stored in your component. The ES6 class component then uses a constructor to initialize local component state. The constructor is called only once, when the component initializes",
            "Set value in state",
            "src/App.js\n\n\nconst list = [\n\n{\n\ntitle: 'React',\n\nurl: 'https://reactjs.org/',\n\nauthor: 'Jordan Walke',\n\nnum_comments: 3,\n\npoints: 4,\n\nobjectID: 0,\n\n},\n\n...\n\n];\n\nclass App extends Component {\n\nconstructor(props) {\n\nsuper(props);\n \nthis.state = {\n\nlist: list,\n\n};\n\n}\n\n...\n\n}\n",
            "The App component is a subclass of Component, so the extends Component is in the App component declaration.\n\nIt is mandatory to call super(props);. It sets this.props in your constructor in case you want to access them there. They would be undefined when accessing this.props in your constructor otherwise. In this case, the initial state of the component should be the sample list of items\n",
            "Display values",
            "src/App.js\n\n\nclass App extends Component {\n\n...\n\nrender() {\n\nreturn (\n\n<div className=\"App\">\n\n{this.state.list.map(item =>\n\n<div key={item.objectID}>\n\n<span>\n\n<a href={item.url}>{item.title}</a>\n\n</span>\n\n<span>{item.author}</span>\n\n<span>{item.num_comments}</span>\n\n<span>{item.points}</span>\n\n</div>\n\n)}\n\n</div>\n\n);\n\n}\n\n}",
            "\nThe state is bound to the class using the this object, so you can access the local state of the whole component. For instance, it can be used in the render() method. Previously you have mapped a static list of items in your render() method that was defined outside of your component. Now you are about to use the list from your local state in your component.\n\nThe list is part of the component now, in the local component state. You could add, change, or remove items from your list. Every time you change your component state, the render() method of your component will run again. That’s how you can change your local component state and see the component re-render the correct data from the local state.Be careful not to mutate the state directly. Instead, you should use a method called setState() to modify your states"
        ],




        "Props in React": [
            "Using Props",
            "App.jsx\n\nimport React from 'react';\n\nclass App extends React.Component {\n   render() {\n      return (\n         <div>\n            <h1>{this.props.headerProp}</h1>\n            <h2>{this.props.contentProp}</h2>\n         </div>\n      );\n   }\n}\nexport default App;\nmain.js\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App.jsx';\n\nReactDOM.render(<App headerProp = \"Header from props...\" contentProp = \"Content\n   from props...\"/>, document.getElementById('app'));\n\nexport default App;",
            "When we need immutable data in our component, we can just add props to reactDOM.render() function in main.js and use it inside our component.",
            "Default Props",
            "App.jsx\n\n\nimport React from 'react';\n\nclass App extends React.Component {\n   render() {\n      return (\n         <div>\n            <h1>{this.props.headerProp}</h1>\n            <h2>{this.props.contentProp}</h2>\n         </div>\n      );\n   }\n}\nApp.defaultProps = {\n   headerProp: \"Header from props...\",\n   contentProp:\"Content from props...\"\n}\nexport default App;\nmain.js\n\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App.jsx';\n\nReactDOM.render(<App/>, document.getElementById('app'));",
            "You can also set default property values directly on the component constructor instead of adding it to the reactDom.render() element.",
            "State and Props",
            "App.jsx\nimport React from 'react';\n\nclass App extends React.Component {\n   constructor(props) {\n      super(props);\n      this.state = {\n         header: \"Header from props...\",\n         content: \"Content from props...\"\n      }\n   }\n   render() {\n      return (\n         <div>\n            <Header headerProp = {this.state.header}/>\n            <Content contentProp = {this.state.content}/>\n         </div>\n      );\n   }\n}\nclass Header extends React.Component {\n   render() {\n      return (\n         <div>\n            <h1>{this.props.headerProp}</h1>\n         </div>\n      );\n   }\n}\nclass Content extends React.Component {\n   render() {\n      return (\n         <div>\n            <h2>{this.props.contentProp}</h2>\n         </div>\n      );\n   }\n}\nexport default App;\nmain.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App.jsx';\n\nReactDOM.render(<App/>, document.getElementById('app'));",
            "The following example shows how to combine state and props in your app. We are setting the state in our parent component and passing it down the component tree using props. Inside the render function, we are setting headerProp and contentProp used in child components.\n\nThe main difference between state and props is that props are immutable. This is why the container component should define the state that can be updated and changed, while the child components should only pass data from the state using props.\n\nThe result in all the examples will be same the only thing that is different is the source of our data, which is now originally coming from the state. When we want to update it, we just need to update the state, and all child components will be updated."
        ],
        "Lists and keys": [
            "Basic List Component",
            "function NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li>{number}</li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\n\n/*Let’s assign a key to our list items inside numbers.map() and fix the missing key issue.*/\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li key={number.toString()}>\n      {number}\n    </li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);",
            "When you run this code, you’ll be given a warning that a key should be provided for list items. A “key” is a special string attribute you need to include when creating lists of elements. We’ll discuss why it’s important in the next section.",
            "Extracting Components with Keys",
            "function ListItem(props) {\n  // Correct! There is no need to specify the key here:\n  return <li>{props.value}</li>;\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // Correct! Key should be specified inside the array.\n    <ListItem key={number.toString()}              value={number} />\n\n  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);",
            "Keys only make sense in the context of the surrounding array.\n\nFor example, if you extract a ListItem component, you should keep the key on the <ListItem /> elements in the array rather than on the <li> element in the ListItem itself."
        ],
        "Component API": [
            "Set State",
            "import React from 'react';\n\nclass App extends React.Component {\n   constructor() {\n      super();\n\t\t\n      this.state = {\n         data: []\n      }\n\t\n      this.setStateHandler = this.setStateHandler.bind(this);\n   };\n   setStateHandler() {\n      var item = \"setState...\"\n      var myArray = this.state.data.slice();\n\t  myArray.push(item);\n      this.setState({data: myArray})\n   };\n   render() {\n      return (\n         <div>\n            <button onClick = {this.setStateHandler}>SET STATE</button>\n            <h4>State Array: {this.state.data}</h4>\n         </div>\n      );\n   }\n}\nexport default App;",
            "setState() method is used to update the state of the component. This method will not replace the state, but only add changes to the original state.",
            "Force Update",
            "import React from 'react';\n\nclass App extends React.Component {\n   constructor() {\n      super();\n      this.forceUpdateHandler = this.forceUpdateHandler.bind(this);\n   };\n   forceUpdateHandler() {\n      this.forceUpdate();\n   };\n   render() {\n      return (\n         <div>\n            <button onClick = {this.forceUpdateHandler}>FORCE UPDATE</button>\n            <h4>Random number: {Math.random()}</h4>\n         </div>\n      );\n   }\n}\nexport default App;",
            "Sometimes we might want to update the component manually. This can be achieved using the forceUpdate() method.",
            "Find Dom Node",
            "import React from 'react';\nimport ReactDOM from 'react-dom';\n\nclass App extends React.Component {\n   constructor() {\n      super();\n      this.findDomNodeHandler = this.findDomNodeHandler.bind(this);\n   };\n   findDomNodeHandler() {\n      var myDiv = document.getElementById('myDiv');\n      ReactDOM.findDOMNode(myDiv).style.color = 'green';\n   }\n   render() {\n      return (\n         <div>\n            <button onClick = {this.findDomNodeHandler}>FIND DOME NODE</button>\n            <div id = \"myDiv\">NODE</div>\n         </div>\n      );\n   }\n}\nexport default App;",
            "For DOM manipulation, we can use ReactDOM.findDOMNode() method. First we need to import react-dom."
        ],
        "Lifecycle Methods": [
            "App.jsx",
            "import React from 'react';\n\nclass App extends React.Component {\n   constructor(props) {\n      super(props);\n      \n      this.state = {\n         data: 0\n      }\n      this.setNewNumber = this.setNewNumber.bind(this)\n   };\n   setNewNumber() {\n      this.setState({data: this.state.data + 1})\n   }\n   render() {\n      return (\n         <div>\n            <button onClick = {this.setNewNumber}>INCREMENT</button>\n            <Content myNumber = {this.state.data}></Content>\n         </div>\n      );\n   }\n}\nclass Content extends React.Component {\n   componentWillMount() {\n      console.log('Component WILL MOUNT!')\n   }\n   componentDidMount() {\n      console.log('Component DID MOUNT!')\n   }\n   componentWillReceiveProps(newProps) {    \n      console.log('Component WILL RECIEVE PROPS!')\n   }\n   shouldComponentUpdate(newProps, newState) {\n      return true;\n   }\n   componentWillUpdate(nextProps, nextState) {\n      console.log('Component WILL UPDATE!');\n   }\n   componentDidUpdate(prevProps, prevState) {\n      console.log('Component DID UPDATE!')\n   }\n   componentWillUnmount() {\n      console.log('Component WILL UNMOUNT!')\n   }\n   render() {\n      return (\n         <div>\n            <h3>{this.props.myNumber}</h3>\n         </div>\n      );\n   }\n}\nexport default App;",
            "In this example, we will set the initial state in the constructor function. The setNewnumber is used to update the state. All the lifecycle methods are inside the Content component.",
            "main.js",
            "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App.jsx';\n\nReactDOM.render(<App/>, document.getElementById('app'));\n\nsetTimeout(() => {\n   ReactDOM.unmountComponentAtNode(document.getElementById('app'));}, 10000);",
            "\nLife Cycle Methods:\n\n•\tstatic getDerivedStateFromProps(props, state) is called before the render() lifecycle method, both on the initial mount and on the subsequent updates. It should return an object to update the state, or null to update nothing. It exists for rare use cases where the state depends on changes in props over time. It is important to know that this is a static method and it doesn’t have access to the component instance.\n\n•\trender() is a mandatory lifecycle method that returns elements as an output of the component. The method should be pure, so it shouldn’t modify the component state. It gets an input as props and state, and returns an element.\n\n•\tcomponentDidMount() is called once, when the component mounted. That’s the perfect time to do an asynchronous request to fetch data from an API. The fetched data is stored in the local component state to display it in the render() lifecycle method.\n\n•\tshouldComponentUpdate(nextProps, nextState) is always called when the component updates due to state or props changes. You will use it in mature React applications for performance optimization. Depending on a boolean that you return from this lifecycle method, the component and all its children will render or will not render on an update lifecycle. You can prevent the render lifecycle method of a component.\n\n•\tgetSnapshotBeforeUpdate(prevProps, prevState) is a lifecycle method, invoked before the most recently rendered output is committed to the DOM. In rare cases, the component needs to capture information from the DOM before it is potentially changed. This lifecycle method enables the component to do it. Another method (componentDidUpdate()) will receive any value returned by getSnapshotBeforeUpdate() as a parameter.\n\n•\tcomponentDidUpdate(prevProps, prevState, snapshot) is a lifecycle method that is invoked immediately after updating, but not for the initial render. You can use it as to perform DOM operations or to perform more asynchronous requests. If your component implements the getSnapshotBeforeUpdate() method, the value it returns will be received as the snapshot parameter.\n\n•\tcomponentWillUnmount() is called before you destroy your component. You can use this lifecycle method to perform any clean up tasks.\n"
        ],
        "Event Handling": [
            "Events Example",
            "class Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n\n    // This binding is necessary to make `this` work in the callback\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(state => ({\n      isToggleOn: !state.isToggleOn\n    }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      </button>\n    );\n  }\n}\n\nReactDOM.render(\n  <Toggle />,\n  document.getElementById('root')\n);",
            "this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states\n\nYou have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.\n\nThis is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.\n\nIf calling bind annoys you, there are two ways you can get around this. If you are using the experimental public class fields syntax, you can use class fields to correctly bind callbacks",
            "Example",
            "class LoggingButton extends React.Component {\n  handleClick() {\n    console.log('this is:', this);\n  }\n\n  render() {\n    // This syntax ensures `this` is bound within handleClick\n    return (\n      <button onClick={() => this.handleClick()}>\n        Click me\n      </button>\n    );\n  }\n}",
            "The problem with this syntax is that a different callback is created each time the LoggingButton renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem."

        ],
        "Conditional Rendering": [
            "Example 1 : Routing",
            "function Greeting(props) {\n  const isLoggedIn = props.isLoggedIn;\n  if (isLoggedIn) {\n    return <UserGreeting />;\n  }\n  return <GuestGreeting />;\n}\n\nReactDOM.render(\n  // Try changing to isLoggedIn={true}:\n  <Greeting isLoggedIn={false} />,\n  document.getElementById('root')\n);",
            "In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.\n\nConditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like if or the conditional operator to create elements representing the current state, and let React update the UI to match them.\n\nConsider these two components:\n\nfunction UserGreeting(props) {\n  return <h1>Welcome back!</h1>;\n}\n\nfunction GuestGreeting(props) {\n  return <h1>Please sign up.</h1>;\n}\nWe’ll create a Greeting component that displays either of these components depending on whether a user is logged in",
            "Example 2 : Login/Logout",
            "class LoginControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleLoginClick = this.handleLoginClick.bind(this);\n    this.handleLogoutClick = this.handleLogoutClick.bind(this);\n    this.state = {isLoggedIn: false};\n  }\n\n  handleLoginClick() {\n    this.setState({isLoggedIn: true});\n  }\n\n  handleLogoutClick() {\n    this.setState({isLoggedIn: false});\n  }\n\n  render() {\n    const isLoggedIn = this.state.isLoggedIn;\n    let button;\n    if (isLoggedIn) {\n      button = <LogoutButton onClick={this.handleLogoutClick} />;\n    } else {\n      button = <LoginButton onClick={this.handleLoginClick} />;\n    }\n\n    return (\n      <div>\n        <Greeting isLoggedIn={isLoggedIn} />\n        {button}\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <LoginControl />,\n  document.getElementById('root')\n);",
            "You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn’t change.\n\nConsider these two new components representing Logout and Login buttons:\n\nfunction LoginButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Login\n    </button>\n  );\n}\n\nfunction LogoutButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Logout\n    </button>\n  );\n}\nIn the example below, we will create a stateful component called LoginControl.\n\nIt will render either <LoginButton /> or <LogoutButton /> depending on its current state. It will also render a <Greeting /> from the previous example\n\nWhile declaring a variable and using an if statement is a fine way to conditionally render a component, sometimes you might want to use a shorter syntax. There are a few ways to inline conditions in JSX, explained below",
            "Example 3 : Inline Operators",
            "render() {\n  const isLoggedIn = this.state.isLoggedIn;\n  return (\n    <div>\n      {isLoggedIn\n        ? <LogoutButton onClick={this.handleLogoutClick} />\n        : <LoginButton onClick={this.handleLoginClick} />\n      }\n    </div>\n  );\n}"
        ],
        "Preventing component from rendering": [
            "Component hide itself even though it was rendered by another component",
            "function WarningBanner(props) {\n  if (!props.warn) {\n    return null;\n  }\n\n  return (\n    <div className=\"warning\">\n      Warning!\n    </div>\n  );\n}\n\nclass Page extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {showWarning: true};\n    this.handleToggleClick = this.handleToggleClick.bind(this);\n  }\n\n  handleToggleClick() {\n    this.setState(state => ({\n      showWarning: !state.showWarning\n    }));\n  }\n\n  render() {\n    return (\n      <div>\n        <WarningBanner warn={this.state.showWarning} />\n        <button onClick={this.handleToggleClick}>\n          {this.state.showWarning ? 'Hide' : 'Show'}\n        </button>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Page />,\n  document.getElementById('root')\n);",
            "In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return null instead of its render output.\n\nIn the example above, the <WarningBanner /> is rendered depending on the value of the prop called warn. If the value of the prop is false, then the component does not render\n\nReturning null from a component’s render method does not affect the firing of the component’s lifecycle methods. For instance componentDidUpdate will still be called."
        ],
        "Forms": [
            "Example 1",
            "import React from 'react';\n\nclass App extends React.Component {\n   constructor(props) {\n      super(props);\n      \n      this.state = {\n         data: 'Initial data...'\n      }\n      this.updateState = this.updateState.bind(this);\n   };\n   updateState(e) {\n      this.setState({data: e.target.value});\n   }\n   render() {\n      return (\n         <div>\n            <input type = \"text\" value = {this.state.data} \n               onChange = {this.updateState} />\n            <h4>{this.state.data}</h4>\n         </div>\n      );\n   }\n}\nexport default App;",
            "In the following example, we will set an input form with value = {this.state.data}. This allows to update the state whenever the input value changes. We are using onChange event that will watch the input changes and update the state accordingly.",
            "Example 2",
            "import React from 'react';\n\nclass App extends React.Component {\n   constructor(props) {\n      super(props);\n      \n      this.state = {\n         data: 'Initial data...'\n      }\n      this.updateState = this.updateState.bind(this);\n   };\n   updateState(e) {\n      this.setState({data: e.target.value});\n   }\n   render() {\n      return (\n         <div>\n            <Content myDataProp = {this.state.data} \n               updateStateProp = {this.updateState}></Content>\n         </div>\n      );\n   }\n}\nclass Content extends React.Component {\n   render() {\n      return (\n         <div>\n            <input type = \"text\" value = {this.props.myDataProp} \n               onChange = {this.props.updateStateProp} />\n            <h3>{this.props.myDataProp}</h3>\n         </div>\n      );\n   }\n}\nexport default App;",
            "In the following example, we will see how to use forms from child component. onChange method will trigger state update that will be passed to the child input value and rendered on the screen. A similar example is used in the Events chapter. Whenever we need to update state from child component, we need to pass the function that will handle updating (updateState) as a prop (updateStateProp)"
        ],
        "React Router": [
            "Install a React Router",
            "C:\\Users\\DevAtom\\Desktop\\reactApp>npm install react-router",
            "A simple way to install the react-router is to run the following code snippet in the command prompt window.",
            "Create Components",
            "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Router, Route, Link, browserHistory, IndexRoute } from 'react-router'\n\nclass App extends React.Component {\n   render() {\n      return (\n         <div>\n            <ul>\n            <li>Home</li>\n            <li>About</li>\n            <li>Contact</li>\n            </ul>\n            {this.props.children}\n         </div>\n      )\n   }\n}\nexport default App;\n\nclass Home extends React.Component {\n   render() {\n      return (\n         <div>\n            <h1>Home...</h1>\n         </div>\n      )\n   }\n}\nexport default Home;\n\nclass About extends React.Component {\n   render() {\n      return (\n         <div>\n            <h1>About...</h1>\n         </div>\n      )\n   }\n}\nexport default About;\n\nclass Contact extends React.Component {\n   render() {\n      return (\n         <div>\n            <h1>Contact...</h1>\n         </div>\n      )\n   }\n}\nexport default Contact;",
            "In this step, we will create four components. The App component will be used as a tab menu. The other three components (Home), (About) and (Contact) are rendered once the route has changed.",
            "Add a Router",
            "ReactDOM.render((\n   <Router history = {browserHistory}>\n      <Route path = \"/\" component = {App}>\n         <IndexRoute component = {Home} />\n         <Route path = \"home\" component = {Home} />\n         <Route path = \"about\" component = {About} />\n         <Route path = \"contact\" component = {Contact} />\n      </Route>\n   </Router>\n), document.getElementById('app'))",
            "Now, we will add routes to the app. Instead of rendering App element like in the previous example, this time the Router will be rendered. We will also set components for each route."
        ],
        "Higher Order Components": [
            "HOC",
            "import React from 'react';\n\nvar newData = {\n   data: 'Data from HOC...',\n}\n\nvar MyHOC = ComposedComponent => class extends React.Component {\n   componentDidMount() {\n      this.setState({\n         data: newData.data\n      });\n   }\n   render() {\n      return <ComposedComponent {...this.props} {...this.state} />;\n   }\n};\nclass MyComponent extends React.Component {\n   render() {\n      return (\n         <div>\n            <h1>{this.props.data}</h1>\n         </div>\n      )\n   }\n}\n\nexport default MyHOC(MyComponent);",
            "Higher order components are JavaScript functions used for adding additional functionalities to the existing component. These functions are pure, which means they are receiving data and returning values according to that data. If the data changes, higher order functions are re-run with different data input. If we want to update our returning component, we don't have to change the HOC. All we need to do is change the data that our function is using.\n\nHigher Order Component (HOC) is wrapping around \"normal\" component and provide additional data input. It is actually a function that takes one component and returns another component that wraps the original one.\n\nLet us take a look at a simple example to easily understand how this concept works. The MyHOC is a higher order function that is used only to pass data to MyComponent. This function takes MyComponent, enhances it with newData and returns the enhanced component that will be rendered on the screen.\n\n\nNote − Higher order components can be used for different functionalities. These pure functions are the essence of functional programming. Once you are used to it, you will notice how your app is becoming easier to maintain or to upgrade."

        ],
        "Refs and the DOM": [
            "Creating Refs",
            "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n  render() {\n    return <div ref={this.myRef} />;\n  }\n}\n",
            "Refs are created using React.createRef() and attached to React elements via the ref attribute. Refs are commonly assigned to an instance property when a component is constructed so they can be referenced throughout the component.",
            "Accessing Refs",
            "const node = this.myRef.current;",
            "The value of the ref differs depending on the type of the node:\n\nWhen the ref attribute is used on an HTML element, the ref created in the constructor with React.createRef() receives the underlying DOM element as its current property.\nWhen the ref attribute is used on a custom class component, the ref object receives the mounted instance of the component as its current.\nYou may not use the ref attribute on function components because they don’t have instances.",
            "Adding a Ref to a DOM Element",
            "class CustomTextInput extends React.Component {\n  constructor(props) {\n    super(props);\n    // create a ref to store the textInput DOM element\n    this.textInput = React.createRef();\n    this.focusTextInput = this.focusTextInput.bind(this);\n  }\n\n  focusTextInput() {\n    // Explicitly focus the text input using the raw DOM API\n    // Note: we're accessing \"current\" to get the DOM node\n    this.textInput.current.focus();\n  }\n\n  render() {\n    // tell React that we want to associate the <input> ref\n    // with the `textInput` that we created in the constructor\n    return (\n      <div>\n        <input\n          type=\"text\"\n          ref={this.textInput} />\n        <input\n          type=\"button\"\n          value=\"Focus the text input\"\n          onClick={this.focusTextInput}\n        />\n      </div>\n    );\n  }\n}",
            "React will assign the current property with the DOM element when the component mounts, and assign it back to null when it unmounts. ref updates happen before componentDidMount or componentDidUpdate lifecycle methods.\n\n",
            "More About Refs and DOM:",
            "In the typical React dataflow, props are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.\n\nWhen to Use Refs\nThere are a few good use cases for refs:\n\nManaging focus, text selection, or media playback.\nTriggering imperative animations.\nIntegrating with third-party DOM libraries.\nAvoid using refs for anything that can be done declaratively.\n\nFor example, instead of exposing open() and close() methods on a Dialog component, pass an isOpen prop to it.\n\nDon’t Overuse Refs\nYour first inclination may be to use refs to “make things happen” in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to “own” that state is at a higher level in the hierarchy. See the Lifting State Up guide for examples of this.\n\nNote\n\nThe examples below have been updated to use the React.createRef() API introduced in React 16.3. If you are using an earlier release of React, we recommend using callback refs instead."
        ],
        "Hooks in React - Part 1": [
            "Introducing Hooks",
            "import React, { useState } from 'react';\n\nfunction Example() {\n  // Declare a new state variable, which we'll call \"count\"\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}",
            "This new function useState is the first “Hook” we’ll learn about, but this example is just a teaser. Don’t worry if it doesn’t make sense yet!",
            "State Hook",
            "import React, { useState } from 'react';\n\nfunction Example() {\n  // Declare a new state variable, which we'll call \"count\"\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}",
            "This example renders a counter. When you click the button, it increments the value.Here, useState is a Hook (we’ll talk about what this means in a moment). We call it inside a function component to add some local state to it. React will preserve this state between re-renders. useState returns a pair: the current state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It’s similar to this.setState in a class, except it doesn’t merge the old and new state together. (We’ll show an example comparing useState to this.state in Using the State Hook.)\n\nThe only argument to useState is the initial state. In the example above, it is 0 because our counter starts from zero. Note that unlike this.state, the state here doesn’t have to be an object — although it can be if you want. The initial state argument is only used during the first render.",
            "Declaring multiple state variables",
            "function ExampleWithManyStates() {\n  // Declare multiple state variables!\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState('banana');\n  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n  // ...\n}",
            "You can use the State Hook more than once in a single component.The array destructuring syntax lets us give different names to the state variables we declared by calling useState. These names aren’t a part of the useState API. Instead, React assumes that if you call useState many times, you do it in the same order during every render. We’ll come back to why this works and when this is useful later.\n\nBut what is a Hook?\nHooks are functions that let you “hook into” React state and lifecycle features from function components. Hooks don’t work inside classes — they let you use React without classes. (We don’t recommend rewriting your existing components overnight but you can start using Hooks in the new ones if you’d like.)\n\nReact provides a few built-in Hooks like useState. You can also create your own Hooks to reuse stateful behavior between different components. We’ll look at the built-in Hooks first.\n\nDetailed Explanation\n\nYou can learn more about the State Hook on a dedicated page: Using the State Hook."
        ],
        "Hooks in React - Part 2":[
            "Effect Hook",
            "import React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // Similar to componentDidMount and componentDidUpdate:\n  useEffect(() => {\n    // Update the document title using the browser API\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}",
            "You’ve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations “side effects” (or “effects” for short) because they can affect other components and can’t be done during rendering.\n\nThe Effect Hook, useEffect, adds the ability to perform side effects from a function component. It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in React classes, but unified into a single API. (We’ll show examples comparing useEffect to these methods in Using the Effect Hook.)\nWhen you call useEffect, you’re telling React to run your “effect” function after flushing changes to the DOM. Effects are declared inside the component so they have access to its props and state. By default, React runs the effects after every render — including the first render. (We’ll talk more about how this compares to class lifecycles in Using the Effect Hook.)",
            "Building Your Own Hooks",
            "import React, { useState, useEffect } from 'react';\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n    };\n  });\n\n  return isOnline;\n}",
            "Sometimes, we want to reuse some stateful logic between components. Traditionally, there were two popular solutions to this problem: higher-order components and render props. Custom Hooks let you do this, but without adding more components to your tree.\n\nEarlier on this page, we introduced a FriendStatus component that calls the useState and useEffect Hooks to subscribe to a friend’s online status. Let’s say we also want to reuse this subscription logic in another component.\n\nFirst, we’ll extract this logic into a custom Hook called useFriendStatus.\nIt takes friendID as an argument, and returns whether our friend is online.\n\nNow we can use it from both components:\n\nfunction FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\nfunction FriendListItem(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  return (\n    <li style={{ color: isOnline ? 'green' : 'black' }}>\n      {props.friend.name}\n    </li>\n  );\n}\nThe state of these components is completely independent. Hooks are a way to reuse stateful logic, not state itself. In fact, each call to a Hook has a completely isolated state — so you can even use the same custom Hook twice in one component.\n\nCustom Hooks are more of a convention than a feature. If a function’s name starts with ”use” and it calls other Hooks, we say it is a custom Hook. The useSomething naming convention is how our linter plugin is able to find bugs in the code using Hooks.\n\nYou can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven’t considered. We are excited to see what custom Hooks the React community will come up with.",
            "Other Hooks",
            "function Example() {\n  const locale = useContext(LocaleContext);\n  const theme = useContext(ThemeContext);\n  // ...\n}\n\n\n\n,function Todos() {\n  const [todos, dispatch] = useReducer(todosReducer);\n  //...",
            "There are a few less commonly used built-in Hooks that you might find useful. For example, useContext lets you subscribe to React context without introducing nesting:\n\nfunction Example() {\n  const locale = useContext(LocaleContext);\n  const theme = useContext(ThemeContext);\n  // ...\n}\nAnd useReducer lets you manage local state of complex components with a reducer:\n\nfunction Todos() {\n  const [todos, dispatch] = useReducer(todosReducer);\n  // ..."
        ],
        "Connecting ReactJs with NodeJs": [
            "Create React and node files separately",
            "npx create-react-app client\ncd client\nnpm start\n\n\nmkdir hello-cli\ncd hello-cli\nnpm init\nnpm install//install the required packages\nnode file.js",
            "After creating files for react app and nodejs app , write the code and run both and different port numbers ",
            "Connecting the React Client to the Express API",
            "constructor(props) {\n    super(props);\n    this.state = { apiResponse: \"\" };\n}\n\ncallAPI() {\n//fetch will contain the url which is running at node server\n    fetch(\"http://localhost:9000/testAPI\")\n        .then(res => res.text())\n        .then(res => this.setState({ apiResponse: res }));\n}\n\ncomponentWillMount() {\n    this.callAPI();\n}",
            "",
            "ERROR ??",
            "npm install --save cors\nvar cors = require(\"cors\");\napp.use(cors());",
            "We are almost done. But if we start both our apps (client and API) and navigate to http://localhost:3000/, you still won't find the expected result displayed on the page. If you open chrome developer tools, you will find why. In the console, you will see this error:\n\nFailed to load http://localhost:9000/testAPI: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost:3000' is therefore not allowed access. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled.\nThis is simple to solve. We just have to add CORS to our API to allow cross-origin requests. Let’s do just that. You should check here to find out more about CORS."
        ]
    }
]